好的，我来帮你把这一大段课程内容整理成一份清晰的 **Markdown 笔记**，结构简洁，便于你随时复习。按照你之前的习惯，我会保证最高级标题只有一个 
# 标准IO

## 一、标准IO基础

### 一、应用层开发的概念

* **应用程序（Application）**：等同于手机上的 APP。
* **Linux 应用层开发**：就是在 Linux 系统上开发应用程序（APP）。
* 不同操作系统（Linux/Windows/Android/iOS）都需要应用程序来支持。

---

### 二、IO（输入输出）

* **IO 含义**：Input/Output，信息交换过程。
* **输入设备**：键盘、鼠标、USB。
* **输出设备**：显示器、网口、USB。
* **双向设备**：网口、U盘（既能输入也能输出）。

---

### 三、标准IO的概念

* 一组 **通用接口**，能在不同系统上运行。
* 基于 **“一切皆文件”** 原则：所有设备统一看作文件。
* 文件的基本操作 = **读**（输出）和 **写**（输入）。

---

### 四、一切皆文件

Linux 下的文件类型：

1. **常规文件**：磁盘上的普通文件（文本、二进制等）。
2. **目录文件**：本质是索引结构。
3. **字符设备文件**：键盘、鼠标（逐字符处理）。
4. **块设备文件**：U盘、磁盘（按块存储）。
5. **管道文件**：进程间通信用。
6. **套接字文件**：网络通信。
7. **符号链接文件**：类似 Windows 快捷方式。

---

### 五、系统调用与库函数

* **系统调用**：

  * 操作系统提供的接口，用来访问内核功能。
  * 如驱动显卡输出字符。
* **库函数**：

  * 编程语言（如 C）提供的函数，封装了系统调用。
  * 示例：`printf` → 调用 C 库函数 → 库函数再调用操作系统的系统调用。
* **作用**：

  * 库函数屏蔽了不同系统调用差异，保证 **跨平台兼容性**。

---

### 六、标准IO的缓冲机制

* **目的**：减少系统调用次数，提高效率。
* **方法**：数据先写入缓冲区，再集中写入磁盘或设备。
* **常见模式**：

  * **全缓冲**：缓冲区满才写入。1024
  * **行缓冲**：遇到换行符刷新。
  * **无缓冲**：实时写入（如标准错误流）。

---

### 七、标准输入输出流

Linux 预定义了三个标准流：

1. **标准输入流 (stdin)**：默认来自键盘。
2. **标准输出流 (stdout)**：默认输出到显示器。
3. **标准错误流 (stderr)**：输出错误信息。

---

### 八、重点知识回顾

* 应用程序 = Linux 上的 APP
* **标准IO**：跨平台、统一接口
* **文件类型**：常规文件、目录、字符设备、块设备、管道、套接字、符号链接
* **系统调用 vs 库函数**：库函数是适配层，系统调用是内核接口
* **缓冲机制**：全缓冲、行缓冲、无缓冲
* **标准流**：stdin / stdout / stderr

---

要不要我帮你再画一张 **知识框架图（思维导图风格）**，把 IO、文件类型、库函数/系统调用、标准流、缓冲机制这些关系用图整理出来？


好的，我来帮你把这一整段内容整理成一个结构化、精炼的 **Markdown 笔记**，方便你快速复习。按照你的要求，只有一个最高级标题 `##`。

---

## 二、文件的打开与关闭

### 一、文件的基本概念
- Linux 中“一切皆文件”，不仅包括常规数据文件，还包括键盘、鼠标、显示器、网口、U盘等 IO 设备。
- **文件打开**：占用资源，确保使用期间不被其他程序干扰。
- **文件关闭**：释放资源，让其他程序可以使用。

---

### 二、文件的打开
- 使用 **fopen** 函数打开文件。
- **函数原型**：
  ```c
  FILE *fopen(const char *path, const char *mode);
  ```

* **返回值**：指向 `FILE` 结构体的指针（文件流）。
* **参数**：

  * `path`：文件路径（相对路径或绝对路径）。
  * `mode`：打开文件的模式（见下表）。
* **注意**：

  * 打开失败返回 `NULL`。
  * 使用前必须判断返回值是否为空，否则可能出现空指针错误。

---

### 三、文件的关闭

* 使用 **fclose** 函数关闭文件。
* 作用：释放占用的资源，避免资源泄漏。

---

### 四、文件打开模式

| 模式     | 含义   | 特点                |
| ------ | ---- | ----------------- |
| `"r"`  | 只读   | 文件必须存在            |
| `"w"`  | 只写   | 文件不存在则创建；存在则清空内容  |
| `"a"`  | 追加写  | 文件不存在则创建；存在则在末尾追加 |
| `"r+"` | 读写   | 文件必须存在；可读写，不会清空   |
| `"w+"` | 读写   | 文件不存在则创建；存在则清空内容  |
| `"a+"` | 读写追加 | 文件不存在则创建；存在则在末尾追加 |

* **r / r+**：文件必须存在。
* **w / w+**：若文件存在，内容清空；否则新建。
* **a / a+**：写入内容总在末尾，不清空原有数据。

---

### 五、重点总结

1. **文件的打开与关闭**：打开 = 占用资源；关闭 = 释放资源。
2. **fopen 使用规则**：返回 `FILE*`，失败返回 `NULL`，必须检查。
3. **文件模式**：六种基本模式，选择时注意 **文件是否必须存在**、**是否清空内容**、**是否追加**。


。
## 三、错误处理


### 一、函数
1. **全局变量 `errno`**  
   - 系统调用/库函数失败时自动设置错误码  
   - **必须包含头文件**：`#include <errno.h>`

2. **错误输出函数**  
   | 函数         | 头文件          | 用法示例                          | 输出示例                            |
   |--------------|-----------------|-----------------------------------|-------------------------------------|
   | `perror()`   | `<stdio.h>`     | `perror("fopen");`                | `fopen: No such file or directory` |
   | `strerror()` | `<string.h>`    | `printf("%s", strerror(errno));`  | `No such file or directory`         |
   - **区别**：  
     - `perror`自动附加错误描述，适合快速输出  
     - `strerror`返回字符串，需手动组合信息，更灵活

3. **编译错误处理**  
   | 错误类型                 | 表现示例                                      | 解决方案                  |
   |--------------------------|---------------------------------------------|--------------------------|
   | `errno`未定义            | `error: 'errno' undeclared`                 | 添加`#include <errno.h>`  |
   | 隐式函数声明（如`strerror`）| `warning: implicit declaration of function`| 添加`#include <string.h>`|

---

### 二、最佳实践
1. **完整文件操作模板**  
```c
#include <stdio.h>
#include <errno.h>
#include <string.h>

FILE *fp = fopen("file.txt", "r");
if (fp == NULL) {
    // 任选一种错误输出方式（勿同时用）
    perror("fopen"); 
    // 或: printf("fopen: %s\n", strerror(errno));
    return 1;
}

// ...文件操作...

if (fclose(fp) != 0) {  // 关闭文件也需检查
    perror("fclose");
}
```

2. **高频避坑指南**  
   - 所有文件操作**必须检查返回值**（尤其`fopen`/`fclose`）  
   - `"w"`模式慎用 → 可能误删文件内容  
   - 路径分隔符：Windows用`\`或`/`，Linux用`/`（建议`/`跨平台兼容）  
   - 多线程环境避免`strerror` → 改用线程安全版`strerror_r`  

> 核心口诀：**开文件判空、读写出错查`errno`、关闭文件验返回**。




## 四、文件关闭（fclose）

### 文件关闭概念

* **文件打开**：占用系统资源，表示正在使用文件。
* **文件关闭**：归还资源，释放缓冲区，为系统和程序后续操作做准备。
* **必要性**：未关闭文件可能导致资源泄漏或数据未写入磁盘。

### fclose 函数

* **定义**：标准 IO 库函数，用于关闭文件。
* **参数**：文件指针 `FILE *fp`，必须非空。
* **返回值**：

  * 成功：返回 `0`
  * 失败：返回 `EOF`（通常为 `-1`）并设置错误号
* **缓冲区处理**：

  * 自动刷新缓冲区，将内存中未写入磁盘的数据写入文件。
  * 释放缓冲区资源。
* **程序终止**：程序结束时，所有打开的文件流会被自动关闭，无需显式调用。

### fclose 使用注意事项

* **参数非空**：传入空指针会导致程序崩溃（断错误）。
* **错误处理**：

  * 检查返回值判断关闭是否成功。
  * 使用 `perror()` 或自定义函数打印错误信息以便调试。
* **缓冲区**：

  * 不论缓冲区是否满，`fclose` 都会刷新内容写入磁盘。
  * 常规文件、打印输出等都受缓冲区机制影响。

### fclose 示例代码

```c
#include <stdio.h>

int main() {
    FILE *fp;
    int ret;

    // 打开文件
    fp = fopen("example.txt", "w");
    if (fp == NULL) {
        perror("文件打开失败");
        return -1;
    }
    printf("文件打开成功\n");

    // 写入数据
    fprintf(fp, "Hello, World!\n");

    // 关闭文件
    ret = fclose(fp);
    if (ret == 0) {
        printf("文件关闭成功\n");
    } else {
        perror("文件关闭失败");
    }

    return 0;
}
```

### 常见问题

* **调用 fclose 时文件未打开**：会出现断错误，程序崩溃。
* **忘记关闭文件**：缓冲区数据可能未写入磁盘，资源未释放。

### 课程重点

1. 文件关闭时自动刷新缓冲区并释放资源。
2. 文件关闭操作的重要性，避免资源泄漏。
3. fclose 参数必须非空，检查返回值进行错误处理。


好的，我已经根据你提供的内容，把文字整理成了**Markdown 格式**笔记，保持逻辑清晰、精简、层次分明，最高级标题只有一个 `##`，便于复习和使用：

---

## 五、单字符读写

### 1. 标准IO的打开与关闭

* 文件打开后可进行读取或写入操作，关闭文件释放资源。
* 错误处理必须加入，防止程序崩溃。
* 打开文件失败需判断返回的 `FILE*` 是否为空。

### 2. 字符输入输出概念

* 按字符读取或写入文件内容。
* 文本文件输入输出是字符输入输出的基础。

#### 2.1 字符输入函数

| 函数        | 功能          | 参数         | 返回值                      |
| --------- | ----------- | ---------- | ------------------------ |
| `fgetc`   | 从文件读取一个字符   | `FILE*` 指针 | 读取的字符（int），出错或 EOF 返回 -1 |
| `getc`    | 从标准输入读取一个字符 | `FILE*` 指针 | 与 `fgetc` 类似             |
| `getchar` | 从键盘读取一个字符   | 无          | 与 `getc(stdin)` 等效       |

* 注意：

  * `fgetc` 返回 `int` 而非 `char`，可处理有符号/无符号字符并区分 EOF。
  * 读取顺序从文件开头开始，读完一个字符，文件指针自动向后移动。
  * 文件关闭后，文件指针失效，需重新打开才能继续操作。

#### 2.2 字符输出函数

| 函数        | 功能         | 参数               | 返回值                 |
| --------- | ---------- | ---------------- | ------------------- |
| `fputc`   | 写一个字符到文件   | `char` + `FILE*` | 写入字符，出错返回 -1        |
| `putc`    | 写一个字符到标准输出 | `char` + `FILE*` | 与 `fputc` 类似        |
| `putchar` | 写一个字符到屏幕   | `char`           | 与 `putc(stdout)` 等效 |

* 注意：

  * 标准输出指针 `stdout` 为系统定义，类型为 `FILE*`。
  * 写入操作出错需判断返回值并进行错误处理。

### 3. 文件指针概念

* 文件指针记录文件当前读写位置。
* 读写操作后，指针会自动移动。
* 关闭文件后，指针失效。
* 文件读取和写入需注意文件位置，防止操作错误。
* 文件操作模式：

  * 只读 `r`：无法写入，尝试写入报错。
  * 只写 `w`：无法读取，尝试读取报错。
  * 读写 `r+`：可同时读写。
  * 追加 `a` / `a+`：写入追加到文件末尾。

### 4. 文件操作错误处理

* 打开文件失败：判断 `FILE*` 是否为空。
* 读写出错：判断函数返回值是否为 -1。
* 打开模式不正确会导致“错误的文件描述符”。

  * 只读模式写入 → 错误
  * 只写模式读取 → 错误
* 错误处理流程：

  1. 打开文件后判断是否成功。
  2. 出现错误打印信息。
  3. 关闭文件释放资源。
  4. 返回或退出，避免后续操作出错。

### 5. 示例流程（按字符读写）

1. 打开文件：

```c
FILE *fp = fopen("file.txt", "r+");
if (!fp) {
    perror("文件打开失败");
    return 0;
}
```

2. 读取一个字符：

```c
int ch = fgetc(fp);
if (ch == EOF) {
    // 错误处理
}
printf("读取字符: %c\n", ch);
```

3. 写入一个字符：

```c
int write_ch = 'w';
if (fputc(write_ch, fp) == EOF) {
    perror("写入出错");
    fclose(fp);
    return 0;
}
```

4. 关闭文件：

```c
fclose(fp);
```

### 6. 练习与注意事项

* `fgetc`、`getc`、`getchar` 用法理解，区别标准输入与文件。
* `fputc`、`putc`、`putchar` 输出到文件或屏幕。
* 文件指针读写顺序、位置移动、关闭文件后的状态。
* 文件模式与操作匹配，防止模式错误导致读写失败。
* 错误处理流程养成习惯，确保代码健壮性。
* 追加模式 `a+` 写入文件末尾，不覆盖原有内容。

---


---

## 六、按行读写

### 一、字符读写

* **概念**：标准I/O中最基本的文件操作，可以实现单个字符的读写。
* **特点**：

  1. 使用简单，无复杂坑点。
  2. 效率较低，不适合处理大量内容。

### 二、行输入输出

* **概念**：按整行进行读取或写入。
* **常用函数**：

  1. **`gets`**（已淘汰）

     * 参数：一个指向缓冲区的指针。
     * 默认从标准输入 (`stdin`) 读取，只能读取键盘输入。
     * 返回值：缓冲区指针，出错返回 `NULL`。
     * **缺点**：未指定读取大小，可能造成缓冲区溢出，安全性差。
  2. **`fgets`**

     * 参数：

       1. 缓冲区指针
       2. size：指定读取的最大字符数
       3. 文件流指针 (`FILE*`)：可从文件或标准输入读取
     * 返回值：缓冲区指针，出错返回 `NULL`
     * **特点**：

       1. 读取 `size-1` 个字符。
       2. 如果输入超过 `size`，截断并在末尾添加 `\0`。
       3. 如果输入不足 `size`，会保留换行符 `\n`。
       4. 安全性高，推荐使用。

### 三、`fgets` 使用要点

1. **缓冲区大小**：

   * 实际读取字符数 = `size - 1`
   * 超过长度会截断，末尾自动加 `\0`
   * 未满长度则会保留换行符
2. **读取来源**：

   * 可以是标准输入 (`stdin`) 或文件流 (`FILE*`)
3. **返回值检查**：

   * 若返回 `NULL`，说明读取失败，需要进行错误处理
4. **示例代码流程**：

   ```c
   #include <stdio.h>
   int main() {
       char buff[100];
       FILE *fp = fopen("test.txt", "r");
       if (!fp) {
           perror("open file failed");
           return 1;
       }
       while (fgets(buff, sizeof(buff), fp) != NULL) {
           printf("%s", buff);
       }
       fclose(fp);
       return 0;
   }
   ```

   * 可逐行读取文件内容，直到文件末尾。
   * 注意 `fgets` 读取超过缓冲区长度的行会被截断，需要循环读取。

### 四、注意事项

1. **不要使用 `gets`**

   * 已淘汰，存在缓冲区溢出风险。
2. **`fgets` 的特殊行为**

   * 输入超过 `size-1`：只保留前 `size-1` 个字符，末尾加 `\0`
   * 输入不足 `size-1`：保留换行符 `\n`，并在末尾加 `\0`
3. **错误处理**

   * 打开文件或读取失败时，应使用 `perror` 打印错误信息，保证程序健壮性。

---


## 七、按行输出

### 一、按行输出函数概述
- 常用按行输出函数有 **puts** 和 **fputs**。
- **puts**
  - 只有一个参数，用于输出字符串到标准输出（屏幕）。
  - 输出后会自动添加换行符。
  - 不支持格式化输出。
- **fputs**
  - 两个参数，第一个为字符串，第二个为输出位置（文件或标准输出）。
  - 不会自动添加换行符。
  - 可指定文件指针，如 `stdout` 输出到屏幕。

### 二、函数使用示例

#### 1. puts 使用示例
```c
#include <stdio.h>

int main() {
    int n;
    n = puts("hello world"); // 输出到屏幕
    if (n == EOF) {
        perror("puts error");
    }
    return 0;
}
````

* 成功返回非负整数，失败返回 `EOF`（通常为 -1）。
* 自动在末尾添加换行符。

#### 2. fputs 使用示例

```c
#include <stdio.h>

int main() {
    FILE *fp = fopen("output.txt", "w");
    if (!fp) {
        perror("fopen error");
        return -1;
    }

    int n = fputs("hello world", fp); // 输出到文件
    if (n == EOF) {
        perror("fputs error");
    }

    fclose(fp);
    return 0;
}
```

* 需要手动添加换行符。
* 第二个参数可为 `stdout` 输出到屏幕，或文件指针输出到文件。

### 三、文件打开模式的重要性

* 打开模式直接影响对文件操作的行为：

  * **只读模式（r）**：只能读取，不能写入。
  * **追加模式（a）**：可以在文件末尾添加数据。
  * **读写模式（r+）**：可读可写，写入从文件开头开始，会覆盖原有内容。
  * **追加读写模式（a+）**：可读可写，写入总是追加到文件末尾。
* 注意：模式选择错误可能导致写入失败或覆盖数据。

### 四、文件操作注意事项

1. **检查返回值**：puts、fputs、fopen 等函数执行后需判断返回值，防止操作失败。
2. **关闭文件**：使用 `fclose(fp)` 释放文件资源，避免文件损坏或内存泄漏。
3. **写入文件时**：确保使用合适的模式，例如想追加写入用 `a` 或 `a+`。
4. **标准输出指针**：`stdout` 可用于输出到屏幕，文件操作需使用有效的文件指针。

### 五、puts 与 fputs 区别总结

| 函数    | 参数数量 | 输出位置  | 自动换行 | 格式化 |
| ----- | ---- | ----- | ---- | --- |
| puts  | 1    | 标准输出  | 是    | 否   |
| fputs | 2    | 文件/屏幕 | 否    | 否   |

* **总结**：puts 简单方便用于屏幕输出；fputs 功能更灵活，可输出到文件或屏幕，但需手动处理换行符和错误检查。


---

## 八、二进制读写

* **`fread` / `fwrite`**

  * 通用的读写函数，既支持文本文件，也支持二进制文件。
  * 常用形式：

    ```c
    size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
    size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
    ```
  * 返回实际成功读/写的块数。

* **内存管理**

  * 使用 `malloc` 动态分配缓冲区，读取完成后必须 `free`。

* **结构体内存布局**

  * 结构体在内存中是连续存储的，可整体作为二进制块写入。
  * `sizeof(struct)` 决定写入/读取的数据大小。

* **ASCII 与二进制差异**

  * 文本模式下是可见字符。
  * 二进制模式下可能出现乱码，这是正常现象。

* **常见错误**

  * 写入后立即读取 → 文件指针在末尾，读不到内容。
  * 解决方法：重新定位文件指针。


```c
#include <stdio.h>
#include <stdlib.h>

// 定义一个学生结构体
typedef struct {
    int id;
    char name[20];
    float score;
} Student;

int main() {
    FILE *fp;
    Student s1 = {1001, "Alice", 95.5};
    Student s2;

    // 1. 写入二进制文件
    fp = fopen("student.dat", "wb");  // wb: write binary
    if (fp == NULL) {
        perror("文件打开失败");
        return EXIT_FAILURE;
    }
    fwrite(&s1, sizeof(Student), 1, fp);  // 写入一个结构体
    fclose(fp);

    // 2. 从二进制文件读取
    fp = fopen("student.dat", "rb");  // rb: read binary
    if (fp == NULL) {
        perror("文件打开失败");
        return EXIT_FAILURE;
    }
    fread(&s2, sizeof(Student), 1, fp);  // 读取一个结构体
    fclose(fp);

    // 3. 打印读取的内容
    printf("ID: %d, Name: %s, Score: %.2f\n", s2.id, s2.name, s2.score);

    return 0;
}
```


---

👉 总结一句话：
**`fread/fwrite` 能直接对内存块进行文件读写，适合处理结构体和二进制数据。但必须注意文件指针位置、内存释放以及数据结构的一致性。**

---




## 九、文件指针与流

### 一、文件指针与读写问题

* 写入文件后，**文件指针在文件末尾**。
* 若立即读取 → **读不到内容**。
* 简单办法：**关闭再打开文件** → 指针回到开头。
* 但若要在 **文件中间** 读写，就需要 **文件定位函数**。

---

### 二、刷新流（fflush）

#### 缓冲区机制

* 标准IO有 **缓冲区**：

  * 缓冲区未满 或 未遇到换行 → 数据不会写入文件/终端。
  * 导致结果 **不能实时可见**。

#### fflush 函数

```c
int fflush(FILE *stream);
```

* 功能：强制将缓冲区数据写入目标（文件/终端）。
* 返回值：`0` 成功，`-1` 失败。
* ⚠ 仅对 **输出缓冲** 有效，输入缓冲会被丢弃。

#### 使用示例

```c
printf("abcdefg");    // 无换行，缓冲区未刷新
fflush(stdout);       // 强制刷新，立即输出到屏幕
```

```c
FILE *fp = fopen("log.txt", "w");
fwrite("abcdefg", 1, 7, fp);
fflush(fp);           // 写入磁盘，文件立即可见
```

✅ 常用于 **实时日志**。

---

### 三、流的定位函数

#### 1. ftell

```c
long ftell(FILE *stream);
```

* 返回当前文件指针位置（字节数）。
* **限制**：仅适用于 **2GB 以下文件**。

---

#### 2. fseek

```c
int fseek(FILE *stream, long offset, int origin);
```

* 改变文件指针位置。
* 参数说明：

  * `stream`：文件流指针
  * `offset`：偏移量（可正可负）
  * `origin`：起始位置

    * `SEEK_SET` → 文件开头
    * `SEEK_CUR` → 当前指针
    * `SEEK_END` → 文件末尾

⚠ 注意：

* 在 **a 模式**（append，追加）下，`fseek` **无效**，写入数据总在末尾。

---

#### 3. rewind

```c
void rewind(FILE *stream);
```

* 将文件指针重置到开头。
* 等价于：

```c
fseek(stream, 0, SEEK_SET);
```

---

### 四、代码示例

#### 1. 使用 fseek 修改文件内容

```c
FILE *fp = fopen("test.txt", "w+");
fwrite("abcdef", 1, 6, fp);

// 将指针向前移动 2 个字节，覆盖 ef
fseek(fp, -2, SEEK_CUR);
fwrite("VV", 1, 2, fp);

fclose(fp);
```

📄 文件结果：`abcdVV`

---

#### 2. 使用 rewind 回到开头

```c
FILE *fp = fopen("test.txt", "w+");
fwrite("abcdef", 1, 6, fp);

rewind(fp);  // 回到文件开头
fwrite("XYZ", 1, 3, fp);

fclose(fp);
```

📄 文件结果：`XYZdef`

---

#### 3. ftell 获取位置

```c
FILE *fp = fopen("test.txt", "w+");
fwrite("abcdef", 1, 6, fp);

long pos = ftell(fp); 
printf("当前指针位置: %ld\n", pos);  // 输出 6

rewind(fp);
printf("重置后位置: %ld\n", ftell(fp));  // 输出 0

fclose(fp);
```

---

### 五、重点总结

* **文件指针操作函数**：`ftell`、`fseek`、`rewind`
* **刷新流函数**：`fflush`
* **模式影响**：

  * `r`、`w` 模式下 → 定位函数可用
  * `a` 模式下 → `fseek` 无效
* **限制**：

  * 仅适用于 **2GB 以下文件**
  * 偏移量为 **有符号数**，支持正负偏移

